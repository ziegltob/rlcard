import os
import numpy as np
import rlcard
from rlcard.envs.okey import OkeyEnv
from rlcard.games.okey.play_okey import OkeyGame
from rlcard.utils import (
    get_device,
    set_seed,
    tournament,
)


def load_model(model_path, env=None, position=None, device=None):
    agent = None
    if model_path.endswith(".onnx"):
        print("Loading ONNX model from", model_path)
        import onnxruntime
        from rlcard.agents import ONNXAgent

        # Create ONNX inference session
        session = onnxruntime.InferenceSession(model_path)

        # Create agent with ONNX runtime session
        agent = ONNXAgent(
            session=session,
            num_actions=env.num_actions if env else None,
            state_shape=env.state_shape[0] if env else None,
        )

    return agent


def evaluate_one_game(env_name, model_path, game: OkeyGame):
    # Check whether gpu is available
    device = get_device()

    # Seed numpy, torch, random
    # set_seed(args.seed)
    # Make the environment with seed
    env: OkeyEnv = rlcard.make(env_name)
    env.game = game

    state = env._extract_state()
    obs_equals = state["obs"] == [
        1,
        1,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        1,
        1,
        1,
    ]

    # Find indices where obs_equals is False
    mismatch_indices = np.where(~obs_equals)[0]
    if len(mismatch_indices) > 0:
        print(f"Mismatch in observation found at indices: {mismatch_indices}")
        print(
            f"Values at first mismatch: Expected={state['obs'][mismatch_indices[0]]}, Got={obs_equals[mismatch_indices[0]]}"
        )

    legal_actions = state["legal_actions"]
    action_keys = np.array(list(legal_actions.keys()))
    all_action_features = np.zeros((1, 194), dtype=np.float32)
    for i, key in enumerate(action_keys):
        all_action_features[0, key] = 1
    actions_equals = all_action_features == [
        1,
        1,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ]

    mismatch_indices_actions = np.where(~actions_equals)[0]
    if len(mismatch_indices_actions) > 0:
        print(f"Mismatch in actions found at indices: {mismatch_indices_actions}")
        print(
            f"Values at first mismatch: Expected={state['legal_actions'][mismatch_indices_actions[0]]}, Got={actions_equals[mismatch_indices_actions[0]]}"
        )

    # Load models
    agents = []
    for position, model_path in enumerate(model_path):
        agents.append(load_model(model_path, env, position, device))
        # return
    env.set_agents(agents)

    reward = env.run(is_training=False)
    print(f"single game reward {env_name}: {reward}")


def evaluate(env_name, model_path, num_games=1000):

    # Check whether gpu is available
    device = get_device()

    # Seed numpy, torch, random
    # set_seed(args.seed)

    # Make the environment with seed
    env = rlcard.make(env_name)

    # Load models
    agents = []
    for position, model_path in enumerate(model_path):
        agents.append(load_model(model_path, env, position, device))
        # return
    env.set_agents(agents)

    # Evaluate
    rewards = tournament(env, num_games)
    for position, reward in enumerate(rewards):
        print(position, model_path[position], reward)


if __name__ == "__main__":
    # evaluate(
    #     # "okey", ["rlcard\\examples\\converted.onnx"], 1000
    #     "okey", ["converted.onnx"], 10000
    # )

    deck = [
        "7b",
        "2y",
        "4b",
        "7y",
        "7r",
        "8b",
        "3y",
        "4y",
        "4r",
        "5b",
        "3b",
        "2b",
        "8y",
        "1y",
        "6r",
        "8r",
        "6b",
        "1b",
        "6y",
    ]
    dealt_cards = ["5r", "1r", "5y", "3r", "2r"]
    game = OkeyGame(dealt_cards=dealt_cards, deck=deck)

    evaluate_one_game(
        "okey",
        ["rlcard\\examples\\converted.onnx"],
        game,
        # "okey",
        # ["converted.onnx"],
        # game,
    )
